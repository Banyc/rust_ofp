var searchIndex = {};
searchIndex["rust_ofp"] = {"doc":"","items":[[0,"learning_switch","rust_ofp","",null,null],[3,"LearningSwitch","rust_ofp::learning_switch","Implements L2 learning switch functionality. Switches forward packets to the\nlearning controller, which will examine the packet and learn the source-port\nmapping. If the controller already knows the destination location, it pushes\na flow entry down to the switch that matches traffic between the packet&#39;s\nsource and destination.",null,null],[11,"new","","",0,{"inputs":[],"output":{"name":"learningswitch"}}],[11,"switch_connected","","",0,null],[11,"switch_disconnected","","",0,null],[11,"packet_in","","",0,null],[0,"ofp_controller","rust_ofp","",null,null],[0,"openflow0x01","rust_ofp::ofp_controller","",null,null],[8,"OF0x01Controller","rust_ofp::ofp_controller::openflow0x01","OpenFlow0x01 Controller API",null,null],[10,"new","","Create a new Controller.",1,{"inputs":[],"output":{"name":"self"}}],[10,"switch_connected","","Callback invoked with `sw` when a switch with identifier `sw` connects to\nthe controller.",1,null],[10,"switch_disconnected","","Callback invoked with `sw` when a switch with identifier `sw` disconnects\nfrom the controller.",1,null],[10,"packet_in","","Callback invoked when a packet `pkt` with transaction ID `xid` from\nswitch `sw` arrives at the controller.",1,null],[11,"send_packet_out","","Send packet `pkt` with transaction ID `xid` to switch `sw` from the controller.",1,{"inputs":[{"name":"u64"},{"name":"u32"},{"name":"packetout"},{"name":"tcpstream"}],"output":null}],[11,"send_flow_mod","","Send flowmod `flow` with transaction ID `xid` to switch `sw` from the controller.",1,{"inputs":[{"name":"u64"},{"name":"u32"},{"name":"flowmod"},{"name":"tcpstream"}],"output":null}],[11,"send_barrier_request","","Send barrier request with transaction ID `xid` to switch `sw` from the controller.\nGuarantees switch `sw` processes messages prior to barrier before messages after.",1,{"inputs":[{"name":"u64"},{"name":"u32"},{"name":"tcpstream"}],"output":null}],[8,"OfpController","rust_ofp::ofp_controller","OpenFlow Controller",null,null],[16,"Message","","OpenFlow message type supporting the same protocol version as the controller.",2,null],[10,"send_message","","Send a message to the node associated with the given `TcpStream`.",2,{"inputs":[{"name":"u32"},{"name":"message"},{"name":"tcpstream"}],"output":null}],[10,"handle_client_connected","","Perform handshake and begin loop reading incoming messages from client stream.",2,{"inputs":[{"name":"tcpstream"}],"output":null}],[0,"ofp_header","rust_ofp","",null,null],[3,"OfpHeader","rust_ofp::ofp_header","OpenFlow Header",null,null],[11,"new","","Create an `OfpHeader` out of the arguments.",3,{"inputs":[{"name":"u8"},{"name":"u8"},{"name":"u16"},{"name":"u32"}],"output":{"name":"ofpheader"}}],[11,"size","","Return the byte-size of an `OfpHeader`.",3,{"inputs":[],"output":{"name":"usize"}}],[11,"marshal","","Fills a message buffer with the header fields of an `OfpHeader`.",3,{"inputs":[{"name":"vec"},{"name":"ofpheader"}],"output":null}],[11,"parse","","Takes a message buffer (sized for an `OfpHeader`) and returns an `OfpHeader`.",3,null],[11,"version","","Return the `version` field of a header.",3,null],[11,"type_code","","Return the OpenFlow message type code of a header.\n# Safety",3,null],[11,"length","","Return the `length` field of a header. Includes the length of the header itself.",3,null],[11,"xid","","Return the `xid` field of a header, the transaction id associated with this packet.\nReplies use the same id to facilitate pairing.",3,null],[0,"ofp_message","rust_ofp","",null,null],[8,"OfpMessage","rust_ofp::ofp_message","OpenFlow Message",null,null],[10,"size_of","","Return the byte-size of an `OfpMessage`.",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"header_of","","Create an `OfpHeader` for the given transaction id and OpenFlow message.",4,{"inputs":[{"name":"u32"},{"name":"self"}],"output":{"name":"ofpheader"}}],[10,"marshal","","Return a marshaled buffer containing an OpenFlow header and the message `msg`.",4,{"inputs":[{"name":"u32"},{"name":"self"}],"output":{"name":"vec"}}],[10,"parse","","Returns a pair `(u32, OfpMessage)` of the transaction id and OpenFlow message parsed from\nthe given OpenFlow header `header`, and buffer `buf`.",4,null],[0,"openflow0x01","rust_ofp","",null,null],[3,"Mask","rust_ofp::openflow0x01","",null,null],[12,"value","","",5,null],[12,"mask","","",5,null],[3,"Pattern","","Fields to match against flows.",null,null],[12,"dl_src","","",6,null],[12,"dl_dst","","",6,null],[12,"dl_typ","","",6,null],[12,"dl_vlan","","",6,null],[12,"dl_vlan_pcp","","",6,null],[12,"nw_src","","",6,null],[12,"nw_dst","","",6,null],[12,"nw_proto","","",6,null],[12,"nw_tos","","",6,null],[12,"tp_src","","",6,null],[12,"tp_dst","","",6,null],[12,"in_port","","",6,null],[3,"Capabilities","","Capabilities supported by the datapath.",null,null],[12,"flow_stats","","",7,null],[12,"table_stats","","",7,null],[12,"port_stats","","",7,null],[12,"stp","","",7,null],[12,"ip_reasm","","",7,null],[12,"queue_stats","","",7,null],[12,"arp_match_ip","","",7,null],[3,"SupportedActions","","Actions supported by the datapath.",null,null],[12,"output","","",8,null],[12,"set_vlan_id","","",8,null],[12,"set_vlan_pcp","","",8,null],[12,"strip_vlan","","",8,null],[12,"set_dl_src","","",8,null],[12,"set_dl_dst","","",8,null],[12,"set_nw_src","","",8,null],[12,"set_nw_dst","","",8,null],[12,"set_nw_tos","","",8,null],[12,"set_tp_src","","",8,null],[12,"set_tp_dst","","",8,null],[12,"enqueue","","",8,null],[12,"vendor","","",8,null],[3,"SwitchFeatures","","Switch features.",null,null],[12,"datapath_id","","",9,null],[12,"num_buffers","","",9,null],[12,"num_tables","","",9,null],[12,"supported_capabilities","","",9,null],[12,"supported_actions","","",9,null],[12,"ports","","",9,null],[3,"FlowMod","","Represents modifications to a flow table from the controller.",null,null],[12,"command","","",10,null],[12,"pattern","","",10,null],[12,"priority","","",10,null],[12,"actions","","",10,null],[12,"cookie","","",10,null],[12,"idle_timeout","","",10,null],[12,"hard_timeout","","",10,null],[12,"notify_when_removed","","",10,null],[12,"apply_to_packet","","",10,null],[12,"out_port","","",10,null],[12,"check_overlap","","",10,null],[3,"PacketIn","","Represents packets received by the datapath and sent to the controller.",null,null],[12,"input_payload","","",11,null],[12,"total_len","","",11,null],[12,"port","","",11,null],[12,"reason","","",11,null],[3,"PacketOut","","Represents packets sent from the controller.",null,null],[12,"output_payload","","",12,null],[12,"port_id","","",12,null],[12,"apply_actions","","",12,null],[3,"FlowRemoved","","Flow removed (datapath -&gt; controller)",null,null],[12,"pattern","","",13,null],[12,"cookie","","",13,null],[12,"priority","","",13,null],[12,"reason","","",13,null],[12,"duration_sec","","",13,null],[12,"duration_nsec","","",13,null],[12,"idle_timeout","","",13,null],[12,"packet_count","","",13,null],[12,"byte_count","","",13,null],[3,"PortState","","Current state of a physical port. Not configurable by the controller.",null,null],[12,"down","","",14,null],[12,"stp_state","","",14,null],[3,"PortFeatures","","Features of physical ports available in a datapath.",null,null],[12,"f_10mbhd","","",15,null],[12,"f_10mbfd","","",15,null],[12,"f_100mbhd","","",15,null],[12,"f_100mbfd","","",15,null],[12,"f_1gbhd","","",15,null],[12,"f_1gbfd","","",15,null],[12,"f_10gbfd","","",15,null],[12,"copper","","",15,null],[12,"fiber","","",15,null],[12,"autoneg","","",15,null],[12,"pause","","",15,null],[12,"pause_asym","","",15,null],[3,"PortConfig","","Flags to indicate behavior of the physical port.",null,null],[12,"down","","",16,null],[12,"no_stp","","",16,null],[12,"no_recv","","",16,null],[12,"no_recv_stp","","",16,null],[12,"no_flood","","",16,null],[12,"no_fwd","","",16,null],[12,"no_packet_in","","",16,null],[3,"PortDesc","","Description of a physical port.",null,null],[12,"port_no","","",17,null],[12,"hw_addr","","",17,null],[12,"name","","",17,null],[12,"config","","",17,null],[12,"state","","",17,null],[12,"curr","","",17,null],[12,"advertised","","",17,null],[12,"supported","","",17,null],[12,"peer","","",17,null],[3,"PortStatus","","A physical port has changed in the datapath.",null,null],[12,"reason","","",18,null],[12,"desc","","",18,null],[4,"MsgCode","","OpenFlow 1.0 message type codes, used by headers to identify meaning of the rest of a message.",null,null],[13,"Hello","","",19,null],[13,"Error","","",19,null],[13,"EchoReq","","",19,null],[13,"EchoResp","","",19,null],[13,"Vendor","","",19,null],[13,"FeaturesReq","","",19,null],[13,"FeaturesResp","","",19,null],[13,"GetConfigReq","","",19,null],[13,"GetConfigResp","","",19,null],[13,"SetConfig","","",19,null],[13,"PacketIn","","",19,null],[13,"FlowRemoved","","",19,null],[13,"PortStatus","","",19,null],[13,"PacketOut","","",19,null],[13,"FlowMod","","",19,null],[13,"PortMod","","",19,null],[13,"StatsReq","","",19,null],[13,"StatsResp","","",19,null],[13,"BarrierReq","","",19,null],[13,"BarrierResp","","",19,null],[13,"QueueGetConfigReq","","",19,null],[13,"QueueGetConfigResp","","",19,null],[4,"PseudoPort","","Port behavior.",null,null],[13,"PhysicalPort","","",20,null],[13,"InPort","","",20,null],[13,"Table","","",20,null],[13,"Normal","","",20,null],[13,"Flood","","",20,null],[13,"AllPorts","","",20,null],[13,"Controller","","",20,null],[13,"Local","","",20,null],[4,"Action","","Actions associated with flows and packets.",null,null],[13,"Output","","",21,null],[13,"SetDlVlan","","",21,null],[13,"SetDlVlanPcp","","",21,null],[13,"SetDlSrc","","",21,null],[13,"SetDlDst","","",21,null],[13,"SetNwSrc","","",21,null],[13,"SetNwDst","","",21,null],[13,"SetNwTos","","",21,null],[13,"SetTpSrc","","",21,null],[13,"SetTpDst","","",21,null],[13,"Enqueue","","",21,null],[4,"Timeout","","How long before a flow entry expires.",null,null],[13,"Permanent","","",22,null],[13,"ExpiresAfter","","",22,null],[4,"FlowModCmd","","Type of modification to perform on a flow table.",null,null],[13,"AddFlow","","",23,null],[13,"ModFlow","","",23,null],[13,"ModStrictFlow","","",23,null],[13,"DeleteFlow","","",23,null],[13,"DeleteStrictFlow","","",23,null],[4,"Payload","","The data associated with a packet received by the controller.",null,null],[13,"Buffered","","",24,null],[13,"NotBuffered","","",24,null],[4,"PacketInReason","","The reason a packet arrives at the controller.",null,null],[13,"NoMatch","","",25,null],[13,"ExplicitSend","","",25,null],[4,"FlowRemovedReason","","Reason a flow was removed from a switch",null,null],[13,"IdleTimeout","","",26,null],[13,"HardTimeout","","",26,null],[13,"Delete","","",26,null],[4,"StpState","","STP state of a port.",null,null],[13,"Listen","","",27,null],[13,"Learn","","",27,null],[13,"Forward","","",27,null],[13,"Block","","",27,null],[4,"PortReason","","What changed about a physical port.",null,null],[13,"PortAdd","","",28,null],[13,"PortDelete","","",28,null],[13,"PortModify","","",28,null],[4,"HelloFailed","","Reason Hello failed.",null,null],[13,"Incompatible","","",29,null],[13,"EPerm","","",29,null],[4,"BadRequest","","Reason the controller made a bad request to a switch.",null,null],[13,"BadVersion","","",30,null],[13,"BadType","","",30,null],[13,"BadStat","","",30,null],[13,"BadVendor","","",30,null],[13,"BadSubType","","",30,null],[13,"EPerm","","",30,null],[13,"BadLen","","",30,null],[13,"BufferEmpty","","",30,null],[13,"BufferUnknown","","",30,null],[4,"BadAction","","Reason the controller action failed.",null,null],[13,"BadType","","",31,null],[13,"BadLen","","",31,null],[13,"BadVendor","","",31,null],[13,"BadVendorType","","",31,null],[13,"BadOutPort","","",31,null],[13,"BadArgument","","",31,null],[13,"EPerm","","",31,null],[13,"TooMany","","",31,null],[13,"BadQueue","","",31,null],[4,"FlowModFailed","","Reason a FlowMod from the controller failed.",null,null],[13,"AllTablesFull","","",32,null],[13,"Overlap","","",32,null],[13,"EPerm","","",32,null],[13,"BadEmergTimeout","","",32,null],[13,"BadCommand","","",32,null],[13,"Unsupported","","",32,null],[4,"PortModFailed","","Reason a PortMod from the controller failed.",null,null],[13,"BadPort","","",33,null],[13,"BadHwAddr","","",33,null],[4,"QueueOpFailed","","Reason a queue operation from the controller failed.",null,null],[13,"BadPort","","",34,null],[13,"BadQueue","","",34,null],[13,"EPerm","","",34,null],[4,"ErrorType","","High-level type of OpenFlow error",null,null],[13,"HelloFailed","","",35,null],[13,"BadRequest","","",35,null],[13,"BadAction","","",35,null],[13,"FlowModFailed","","",35,null],[13,"PortModFailed","","",35,null],[13,"QueueOpFailed","","",35,null],[4,"Error","","Error message (datapath -&gt; controller)",null,null],[13,"Error","","",36,null],[0,"message","","Encapsulates handling of messages implementing `MessageType` trait.",null,null],[4,"Message","rust_ofp::openflow0x01::message","Abstractions of OpenFlow 1.0 messages mapping to message codes.",null,null],[13,"Hello","","",37,null],[13,"Error","","",37,null],[13,"EchoRequest","","",37,null],[13,"EchoReply","","",37,null],[13,"FeaturesReq","","",37,null],[13,"FeaturesReply","","",37,null],[13,"FlowMod","","",37,null],[13,"PacketIn","","",37,null],[13,"FlowRemoved","","",37,null],[13,"PortStatus","","",37,null],[13,"PacketOut","","",37,null],[13,"BarrierRequest","","",37,null],[13,"BarrierReply","","",37,null],[5,"add_flow","","Return a `FlowMod` adding a flow parameterized by the given `priority`, `pattern`,\nand `actions`.",null,{"inputs":[{"name":"u16"},{"name":"pattern"},{"name":"vec"}],"output":{"name":"flowmod"}}],[5,"parse_payload","","Parse a payload buffer into a network level packet.",null,{"inputs":[{"name":"payload"}],"output":{"name":"packet"}}],[11,"size_of","","",37,{"inputs":[{"name":"message"}],"output":{"name":"usize"}}],[11,"header_of","","",37,{"inputs":[{"name":"u32"},{"name":"message"}],"output":{"name":"ofpheader"}}],[11,"marshal","","",37,{"inputs":[{"name":"u32"},{"name":"message"}],"output":{"name":"vec"}}],[11,"parse","","",37,null],[8,"MessageType","rust_ofp::openflow0x01","Common API for message types implementing OpenFlow Message Codes (see `MsgCode` enum).",null,null],[10,"size_of","","Return the byte-size of a message.",38,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"parse","","Parse a buffer into a message.",38,null],[10,"marshal","","Marshal a message into a `u8` buffer.",38,{"inputs":[{"name":"self"},{"name":"vec"}],"output":null}],[11,"clone","","",19,null],[11,"fmt","","",19,null],[11,"match_all","","",6,{"inputs":[],"output":{"name":"pattern"}}],[11,"clone","","",20,null],[11,"clone","","",21,null],[11,"size_of","","",9,{"inputs":[{"name":"switchfeatures"}],"output":{"name":"usize"}}],[11,"parse","","",9,null],[11,"marshal","","",9,{"inputs":[{"name":"switchfeatures"},{"name":"vec"}],"output":null}],[11,"size_of","","",10,{"inputs":[{"name":"flowmod"}],"output":{"name":"usize"}}],[11,"parse","","",10,null],[11,"marshal","","",10,{"inputs":[{"name":"flowmod"},{"name":"vec"}],"output":null}],[11,"fmt","","",24,null],[11,"size_of","","",24,{"inputs":[{"name":"payload"}],"output":{"name":"usize"}}],[11,"fmt","","",25,null],[11,"fmt","","",11,null],[11,"size_of","","",11,{"inputs":[{"name":"packetin"}],"output":{"name":"usize"}}],[11,"parse","","",11,null],[11,"marshal","","",11,{"inputs":[{"name":"packetin"},{"name":"vec"}],"output":null}],[11,"size_of","","",12,{"inputs":[{"name":"packetout"}],"output":{"name":"usize"}}],[11,"parse","","",12,null],[11,"marshal","","",12,{"inputs":[{"name":"packetout"},{"name":"vec"}],"output":null}],[11,"size_of","","",13,{"inputs":[{"name":"flowremoved"}],"output":{"name":"usize"}}],[11,"parse","","",13,null],[11,"marshal","","",13,{"inputs":[{"name":"flowremoved"},{"name":"vec"}],"output":null}],[11,"size_of","","",18,{"inputs":[{"name":"portstatus"}],"output":{"name":"usize"}}],[11,"parse","","",18,null],[11,"marshal","","",18,{"inputs":[{"name":"portstatus"},{"name":"vec"}],"output":null}],[11,"fmt","","",29,null],[11,"fmt","","",30,null],[11,"fmt","","",31,null],[11,"fmt","","",32,null],[11,"fmt","","",33,null],[11,"fmt","","",34,null],[11,"fmt","","",35,null],[11,"fmt","","",36,null],[11,"size_of","","",36,{"inputs":[{"name":"error"}],"output":{"name":"usize"}}],[11,"parse","","",36,null],[11,"marshal","","",36,{"inputs":[{"name":"error"},{"name":"vec"}],"output":null}],[0,"packet","rust_ofp","",null,null],[3,"TcpFlags","rust_ofp::packet","TCP Header flags.",null,null],[12,"ns","","ECN-nonce concealment protection.",39,null],[12,"cwr","","Congestion window reduced.",39,null],[12,"ece","","ECN-Echo.",39,null],[12,"urg","","Indicates the Urgent pointer field is significant.",39,null],[12,"ack","","Indicates that the Acknowledgment field is significant.",39,null],[12,"psh","","Asks to push the buffered data to the receiving application.",39,null],[12,"rst","","Reset the connection.",39,null],[12,"syn","","Synchronize sequence numbers.",39,null],[12,"fin","","No more data from sender.",39,null],[3,"Tcp","","TCP frame of a packet.",null,null],[12,"src","","",40,null],[12,"dst","","",40,null],[12,"seq","","",40,null],[12,"ack","","",40,null],[12,"offset","","",40,null],[12,"flags","","",40,null],[12,"window","","",40,null],[12,"chksum","","",40,null],[12,"urgent","","",40,null],[12,"payload","","",40,null],[3,"Udp","","UDP frame of a packet.",null,null],[12,"src","","",41,null],[12,"dst","","",41,null],[12,"chksum","","",41,null],[12,"payload","","",41,null],[3,"Icmp","","ICMP frame of a packet.",null,null],[12,"typ","","",42,null],[12,"code","","",42,null],[12,"chksum","","",42,null],[12,"payload","","",42,null],[3,"Flags","","The type of IPv4 flags.",null,null],[12,"dont_fragment","","",43,null],[12,"more_fragments","","",43,null],[3,"Ip","","IPv4 frame of a packet.",null,null],[12,"tos","","",44,null],[12,"ident","","",44,null],[12,"flags","","",44,null],[12,"frag","","",44,null],[12,"ttl","","",44,null],[12,"chksum","","",44,null],[12,"src","","",44,null],[12,"dst","","",44,null],[12,"options","","",44,null],[12,"tp","","",44,null],[3,"Packet","","Represents a packet at the ethernet protocol level.",null,null],[12,"dl_src","","",45,null],[12,"dl_dst","","",45,null],[12,"dl_vlan","","",45,null],[12,"dl_vlan_dei","","",45,null],[12,"dl_vlan_pcp","","",45,null],[12,"nw","","",45,null],[4,"Tp","","Represents packets at the transport protocol level, which are encapsulated\nwithin the IPv4 payload. At present, we only support TCP, UDP, and ICMP\nexplicitly; otherwise, the raw bytes and IPv4 protocol number are provided.",null,null],[13,"Tcp","","",46,null],[13,"Udp","","",46,null],[13,"Icmp","","",46,null],[13,"Unparsable","","",46,null],[4,"Arp","","Address resolution protocol (ARP) packet payload.",null,null],[13,"Query","","",47,null],[13,"Reply","","",47,null],[4,"Nw","","Represents a packet at the network protocol level.",null,null],[13,"Ip","","",48,null],[13,"Arp","","",48,null],[13,"Unparsable","","",48,null],[5,"bytes_of_mac","","",null,null],[5,"mac_of_bytes","","",null,null],[11,"fmt","","",39,null],[11,"fmt","","",40,null],[11,"fmt","","",41,null],[11,"fmt","","",42,null],[11,"fmt","","",46,null],[11,"fmt","","",43,null],[11,"fmt","","",44,null],[11,"fmt","","",47,null],[11,"fmt","","",48,null],[11,"fmt","","",45,null],[11,"parse","","",45,null]],"paths":[[3,"LearningSwitch"],[8,"OF0x01Controller"],[8,"OfpController"],[3,"OfpHeader"],[8,"OfpMessage"],[3,"Mask"],[3,"Pattern"],[3,"Capabilities"],[3,"SupportedActions"],[3,"SwitchFeatures"],[3,"FlowMod"],[3,"PacketIn"],[3,"PacketOut"],[3,"FlowRemoved"],[3,"PortState"],[3,"PortFeatures"],[3,"PortConfig"],[3,"PortDesc"],[3,"PortStatus"],[4,"MsgCode"],[4,"PseudoPort"],[4,"Action"],[4,"Timeout"],[4,"FlowModCmd"],[4,"Payload"],[4,"PacketInReason"],[4,"FlowRemovedReason"],[4,"StpState"],[4,"PortReason"],[4,"HelloFailed"],[4,"BadRequest"],[4,"BadAction"],[4,"FlowModFailed"],[4,"PortModFailed"],[4,"QueueOpFailed"],[4,"ErrorType"],[4,"Error"],[4,"Message"],[8,"MessageType"],[3,"TcpFlags"],[3,"Tcp"],[3,"Udp"],[3,"Icmp"],[3,"Flags"],[3,"Ip"],[3,"Packet"],[4,"Tp"],[4,"Arp"],[4,"Nw"]]};
searchIndex["rust_ofp_controller"] = {"doc":"","items":[],"paths":[]};
searchIndex["byteorder"] = {"doc":"This crate provides convenience methods for encoding and decoding numbers\nin either big-endian or little-endian order.","items":[[4,"BigEndian","byteorder","Defines big-endian serialization.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[6,"NetworkEndian","","Defines network byte order serialization.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[8,"ReadBytesExt","","Extends `Read` with methods for reading numbers. (For `std::io`.)",null,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[8,"WriteBytesExt","","Extends `Write` with methods for writing numbers. (For `std::io`.)",null,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null],[8,"ByteOrder","","ByteOrder describes types that can serialize integers as bytes.",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",2,null],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",2,null],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",2,null],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",2,null],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",2,null],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",2,null],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",2,null],[10,"write_uint","","Writes an unsigned integer `n` to `buf` using only `nbytes`.",2,null],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",2,null],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",2,null],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",2,null],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",2,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",2,null],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",2,null],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",2,null],[11,"write_int","","Writes a signed integer `n` to `buf` using only `nbytes`.",2,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"hash","","",3,null],[11,"cmp","","",3,null],[11,"eq","","",3,null],[11,"partial_cmp","","",3,null],[11,"default","","",3,{"inputs":[],"output":{"name":"bigendian"}}],[11,"clone","","",4,null],[11,"fmt","","",4,null],[11,"hash","","",4,null],[11,"cmp","","",4,null],[11,"eq","","",4,null],[11,"partial_cmp","","",4,null],[11,"default","","",4,{"inputs":[],"output":{"name":"littleendian"}}],[11,"read_u16","","",3,null],[11,"read_u32","","",3,null],[11,"read_u64","","",3,null],[11,"read_uint","","",3,null],[11,"write_u16","","",3,null],[11,"write_u32","","",3,null],[11,"write_u64","","",3,null],[11,"write_uint","","",3,null],[11,"read_u16","","",4,null],[11,"read_u32","","",4,null],[11,"read_u64","","",4,null],[11,"read_uint","","",4,null],[11,"write_u16","","",4,null],[11,"write_u32","","",4,null],[11,"write_u64","","",4,null],[11,"write_uint","","",4,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null]],"paths":[[8,"ReadBytesExt"],[8,"WriteBytesExt"],[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
initSearch(searchIndex);
